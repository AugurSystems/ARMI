/*
 * Copyright 2012, Augur Systems, Inc.  All rights reserved.
 */
package com.augursystems.armi;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.io.Serializable;
import java.net.Socket;
import java.util.HashMap;
import java.util.Map;

/**
 * Encapsulates a connection to a remote ARMI server.
 * Synchronizes all data sent to the remote server, as generated by subscriptions
 * and method calls.  Sent data is managed by a thread, to isolate the sender
 * from a potentially stuck remote connection.
 * 
 * @author Chris.Janicki@AugurSystems.com
 */
class ArmiRemote extends Object implements Runnable
{
	private static final int BUFF_SIZE = 1024*1024;
	protected final HostPort hostPort;
	private final ByteArrayOutputStream bout;
	private final ArmiOutputStreamHeaderless aout;
	private final OutputStream sout;
	private final QueueBytes queue = new QueueBytes(BUFF_SIZE, true, false);
	private final byte[] data = new byte[BUFF_SIZE];
	private Armi armi;
	private Receiver receiver;
	private volatile boolean runnable = true;
	private final String name;
	private final Map<Integer,SynchronousCall> calls = new HashMap<Integer,SynchronousCall>();


	/** You must call start() after instantiating this. */
	protected ArmiRemote(HostPort remoteHostPort, Armi armi, Socket socket) throws IOException
	{
		this.name = "Remote ARMI @ " + remoteHostPort;
		this.hostPort = remoteHostPort;
		this.armi = armi;
		sout = socket.getOutputStream();
		receiver = new Receiver(armi, this, socket);
		bout = new ByteArrayOutputStream();
		aout = new ArmiOutputStreamHeaderless(bout); // the ObjectOutputStream superclass will write a stream header here!
		aout.flush(); // flush header into ByteArrayOutputStream
		int z = bout.size();
		if (z>0) // contains stream header!
		{
			byte[] ba = bout.toByteArray();
			bout.reset();
			if (Armi.debug) System.out.println(Thread.currentThread().getName()+"> ArmiRemote> Writing header of length "+z+" = "+ba[0]+","+ba[1]+","+ba[2]+","+ba[3]);
			synchronized(queue) // protect time between hasCapacity() and write(); note that queue internally syncs on itself too
			{
				if (!queue.hasCapacity(z)) { throw new IOException("No room in buffer to transmit() stream header of length "+z); }
				queue.write(ba,0,z);
			}
		}
	}

	final boolean isRunnable()
	{
		return runnable;
	}
	

	/**
	 * Execute a remote method (synchronously, like RMI);
	 * this method will block (hopefully for only microseconds) until the response is received.
	 *
	 * @param serviceName  The String name of the service, as registered by the service on the remote server.
	 * @param method  The String method name to call on the remote service; this is the
	 * actual name of a public Java method within the service's implementing class.
	 * @param args  The Serializable[] of method arguments; may be null if the method has no parameters
	 *
	 * @return The Serializable value returned from the call.
	 * 
	 * @throws ArmiException if anything goes wrong; it is usually
	 * received from the remote server.  If the ArmiException.getCause() is an IOException,
	 * it usually means that there was a problem contacting the remote server.
	 * 
	 * @throws IOException if there is a problem transmitting the call's packet to the remote server
	 * 
	 * TODO: Use the time-out form of the openRemoteServer() to optionally specify a non-default time-out for callers
	 */
	@SuppressWarnings("CallToThreadDumpStack")
	public final Serializable call(String serviceName, String method, Serializable[] args) throws ArmiException, IOException
	{
		SynchronousCall call = new SynchronousCall(serviceName, method, args);
		calls.put(call.serial, call);
		// send off the call to the remote server...
		Packet p = new Packet(call);
		transmit(p); // throws IOException
		// block until response received...
		if (Armi.debug) Armi.log("Waiting for response to: " +call);
		SynchronousResponse response;
		try 
		{ 
			response = call.getResponse(); // blocking 
			if (Armi.debug) Armi.log("Got response for, will cancel: " +call);
		}
		catch (InterruptedException ie) { throw new ArmiException(ie.getMessage(), ie); } // call timed-out, remote server disconnected, etc.
		if (response.response instanceof ArmiException) { throw (ArmiException)response.response; }
		return response.response;
	}

	
	/**
	 * Should be called immediately after instantiation.
	 * (Taken out of constructor for good concurrency form.)
	 */
	public void start()
	{
		receiver.start();
		Thread t = new Thread(this,"Writer to Remote Server @ "+hostPort);
		t.setDaemon(true);
		t.start();
	}


	/**
	 * Transmits a Packet to the remote server.
	 * Sync'd on itself to protect the HEADER byte[].
	 * Sync'd on 'queue' with calls to invoke() since both write on the stream.
	 */
	protected synchronized void transmit(Packet p) throws IOException
	{
		if (!isRunnable()) { throw new IOException("This RemoteServer has been shut down."); }
		aout.reset();
		aout.writeObject(p);
		aout.flush();
		aout.reset(); // clear object cache in ObjectOutputStream
		int z = bout.size();
		byte[] ba = bout.toByteArray();
		bout.reset();
		synchronized(queue) // protect time between hasCapacity() and write(); note that queue internally syncs on itself too
		{
			if (!queue.hasCapacity(z)) { throw new IOException("No room in buffer to transmit() packet: "+p); }
			queue.write(ba, 0, z);
		}
	}


	/**
	 * Transmits a Packet to the remote server.
	 * Sync'd with calls to invoke() since both write on the stream.
	 */
	protected void transmit(Serializable a, String dataFlavor) throws IOException
	{
		Packet p = new Packet(a, dataFlavor);
		transmit(p);
	}

	/** 
	 * Transmits the given Serializable in a flavor-less packet.
	 * @param a  The Serializable to be sent
	 * @throws IOException
	 */
	protected void transmit(Serializable a) throws IOException
	{
		transmit(a, null);
	}

	protected final void shutdown()
	{
		//System.out.println(Thread.currentThread().getName()+"> ArmiRemote> =======================");
		if (Armi.debug) 
		{
			System.out.println(Thread.currentThread().getName() + "> ArmiRemote> shutdown() called at " + System.currentTimeMillis()+"; stack dump:");
			Thread.dumpStack();
		}
		if (isRunnable())
		{
			runnable = false;
			if (receiver.isRunnable()) // may have already closed if it initiated our shutdown
			{
				receiver.close(Armi.REASON_SHUTDOWN_REQ); // just sets runnable=false
				receiver = null; // help GC
			}
			// abort any calls waiting on this remote
			for (SynchronousCall call : calls.values())
			{
				call.abort(Armi.REASON_SHUTDOWN_REQ);
			}
			//
			try { aout.close(); sout.close(); } // will bubble up to socket; this wakes up receiver too
			catch (IOException ioe) { Armi.log(Thread.currentThread().getName()+"> Problem closing connection to remote server @ "+hostPort, ioe); }
			// queue.close(); // currently noop
			queue.unblock();
			armi.closeRemoteServer(this); // in case call came from Receiver instead of serverLocal
			armi = null; // help GC
		}
	}


	/** 
	 * Called by the Receiver when it receives a SynchronousResponse from the
	 * remote ARMI server, in response to our previous invoke().
	 */
	protected void handleResponse(SynchronousResponse res)
	{
		SynchronousCall call = calls.get(res.serial);
		if (call!=null) call.handleResponse(res);
	}
	
	
	@Override	public boolean equals(Object obj)
	{
		return obj instanceof ArmiRemote &&
			hostPort.equals(((ArmiRemote)obj).hostPort);
	}


	@Override	public int hashCode()
	{
		return hostPort.hashCode();
	}

	@Override	public String toString()
	{
		return name;
	}


	@Override public void run()
	{
		int i;
		while (isRunnable())
		{
			i = queue.read(data, 0, data.length); // blocks until data available in queue, or unblocked by shutdown()
			if (i>0)
			{
				try
				{
					if (Armi.debug) { System.out.println(Thread.currentThread().getName()+"> ArmiRemote> Writing "+i+" bytes @ "+System.currentTimeMillis()); }
					sout.write(data, 0, i);
					sout.flush();
					if (Armi.debug) { System.out.println(Thread.currentThread().getName()+"> ArmiRemote> Wrote "+i+" bytes @ "+System.currentTimeMillis()); }
				}
				catch (IOException ioe)
				{
					Armi.log(Thread.currentThread().getName()+"> Problem writing to remote @ "+System.currentTimeMillis()+"; will shutdown "+hostPort, ioe);
					shutdown();
				}
			}
		}
	}

}
